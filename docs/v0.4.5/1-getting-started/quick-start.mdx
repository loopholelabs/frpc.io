---
title: Quick Start
order: 1
---

In this section we'll be going over how you can quickly get started with <Tooltip text={"Frisbee RPC"} content={"FRPC"}/>,
from defining your message types in a <Tooltip text={"Syntax used to describe protocol buffers"} content={"proto3"}/> file, to writing your first server and client.

We'll be building a simple echo service that will echo back the message it receives, and later on we'll also show how
you can use the Frisbee framework itself to build a more complex <Tooltip text={"Publish and Subscribe"} content={"PUB\/SUB"}/> service.

# Installation

To get started with <Tooltip text={"Frisbee RPC"} content={"FRPC"}/>, you'll need to make sure you have `Go{:.keyword}`
and the `protoc{:.keyword}` compiler installed. Then, you'll need to install
the `protoc-gen-frpc{:.keyword}` <Tooltip text={"Plugins hook into the protoc compiler and allow for custom code generation"} content={"protoc plugin"}/>
which we will use to generate the server and client code.

## Prerequisites

- [Go](https://golang.org/doc/install) - FRPC works with `Go` version 1.17 or later. For installation instructions see [Go's Getting Started Guide](https://golang.org/doc/install).
- [Protocol Buffer Compiler (protoc)](https://developers.google.com/protocol-buffers) - FRPC works with `protoc{:.keyword}` version 3. For installation instructions see the [Protoc Getting Started Guide](https://developers.google.com/protoc/docs/getting_started).

If you're using MacOS and have [Brew](https://brew.sh/) installed, you can use `brew install go{:.keyword}`
to install Golang, and `brew install protoc{:.keyword}` to install the protoc compiler.

## Install the FRPC Plugin

To install the `protoc-gen-frpc{:.keyword}` plugin, you'll first need to make sure that your

`$GOBIN{:.keyword}` environment variable is set and available in
your system path. See the [Go Environment Variables](https://golang.org/doc/code.html#GOPATH)
for more information, but in general, you can do this by adding the following to
your `~/.bashrc{:.keyword}` file:

```bash title="~/.bashrc"
export GOBIN=$GOPATH/bin
export PATH=$PATH:$GOBIN
```

To install the `protoc-gen-frpc{:.keyword}` plugin itself, you'll need to run the following command:

```bash
$ go install github.com/loopholelabs/frisbee/protoc-gen-frpc@latest
```

This will install the `protoc-gen-frpc{:.keyword}` plugin into your `$GOBIN{:.keyword}` directory
where it will be available for use by the `protoc{:.keyword}` compiler.

You can check that the plugin is installed and available by running the following command:

```bash
$ which protoc-gen-frpc
/Users/<username>/go/bin/protoc-gen-frpc # or $GOPATH/bin/protoc-gen-frpc
```

# Create a Proto3 File

Now that we have the prerequisites and the `protoc-gen-frpc{:.keyword}` plugin installed,
we can start writing our echo service. Let's start by creating a directory to house our project:

```bash
$ mkdir -p ~/frpc/echo
$ cd ~/frpc/echo
```

Now we'll create an `echo.proto{:.keyword}` file and define our message types:

```proto title="~/echo/echo.proto"
syntax = "proto3";

option go_package = "/echo";

message Request {
  string Message = 1;
}

message Response{
  string Message = 1;
}
```

You can see that we've defined two message types, one for the `Request{:.keyword}` and one for the `Response{:.keyword}`.

Next, we will define a new `EchoService{:.variable}` in our `proto3{:.keyword}` file. This tells the compiler that we want to generate a server and client for this service.

```proto {5-7} title="~/echo/echo.proto"
syntax = "proto3";

option go_package = "/echo";

service EchoService {
  rpc Echo(Request) returns (Response);
}

message Request {
  string Message = 1;
}

message Response{
  string Message = 1;
}
```

And with that you should be ready. Next we'll start the `protoc{:.keyword}` compiler to generate
our FRPC server and client.

# Generate the Server and Client

Let's run the following command to generate the server and client code:

```bash
$ protoc --frisbee_out=. echo.proto
```

This command tells the `protoc{:.keyword}` compiler to generate the server and client code for us and
by specifying the `--frisbee_out{:.keyword}` flag, we're implicitly specifying that we want to use the `protoc-gen-frpc{:.keyword}` plugin.

If we wanted to be more explicit, we could have run the following command:

```bash
$ protoc --plugin=protoc-gen-frpc=$GOBIN/protoc-gen-frpc --frisbee_out=. echo.proto
```

These commands should have generated a new folder at `~/echo/echo{:.keyword}`, which
contains an `echo.frpc.go{:.keyword}` file containing the server and client code. Within
that file, you'll find the following interface:

```go title="echo.frisbee.go"
...

type EchoService interface {
	Echo(context.Context, *Request) (*Response, error)
}

...
```

All we have left to do is implement the `EchoService{:.variable}` interface with our server-side logic,
and pass that into the server. The generated library will then be able to handle everything else for us.

# Setting up the Server

To set up our server, we simply need to implement the `EchoService{:.variable}` interface and then start
the server. We'll start by creating a new `server/main.go{:.keyword}` file in our `~/frpc/echo{:.keyword}` directory:

```go title="~/echo/server/server.go"
package main

import (
	"context"
    "frisbee-examples/echo/echo"
)

type svc struct{}

func (s *svc) Echo(_ context.Context, req *echo.Request) (*echo.Response, error) {
	res := new(echo.Response)
	res.Message = req.Message
	return res, nil
}
```

As you can see we've created a new struct called `svc{:.variable}` and implemented the `EchoService{:.variable}` interface by
creating a new function called `Echo{:.function}` which takes a `context.Context{:go}` and an `*echo.Request{:go}` object.
We aren't really using the context in this example so we just ignore that and instead return an `*echo.Response{:go}` object with the
same message as the request.

Now we can implement the server itself:

```go {22-32} title="~/echo/server/server.go"
package main

import (
	"context"
	"github.com/loopholelabs/frisbee"
	"github.com/rs/zerolog"
    "frisbee-examples/echo/echo"
	"log"
	"os"
	"runtime"
	"time"
)

type svc struct{}

func (s *svc) Echo(_ context.Context, req *echo.Request) (*echo.Response, error) {
	res := new(echo.Response)
	res.Message = req.Message
	return res, nil
}

func main() {
	frpcServer, err := echo.NewServer(new(svc), nil, nil)
	if err != nil {
		panic(err)
	}

	err = frisbeeServer.Start(":8080")
    if err != nil {
        panic(err)
    }
}

```

This additional `main{:.keyword}` function runs when the server starts up, and passes in our `svc{:.variable}` struct to the
generated `echo.NewServer(){:go}` function. It then binds the server to port `:8080{:.keyword}` and starts listening for connections.

# Setting up the Client

To set up our client, we don't need to implement any additional logic, but we do need to create a new `client/main.go{:.keyword}` file
in our `~/frpc/echo{:.keyword}` directory:

```go title="~/echo/client/client.go"
package main

import (
	"context"
	"fmt"
	"frisbee-examples/echo/echo"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"
)

func main() {
	c, err := echo.NewClient(nil, nil)
	if err != nil {
		panic(err)
	}

	err = c.Connect("127.0.0.1:8080")
	if err != nil {
		panic(err)
	}
}
```

Here, we're creating a new echo client using our generated `echo.NewClient(){:go}` function.
Then, we're passing in the address of the server we want to connect to. But we're not actually sending any
requests to the server yet.

To do that, we can write a simple look to send a request to the server every second and then print out the response:

```go {25-50} title="~/echo/client/client.go"
package main

import (
	"context"
	"fmt"
	"frisbee-examples/echo/echo"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"
)

func main() {
	c, err := echo.NewClient(nil, nil)
	if err != nil {
		panic(err)
	}

	err = c.Connect("127.0.0.1:8080")
	if err != nil {
		panic(err)
	}

	stop := make(chan os.Signal, 1)
	signal.Notify(stop, os.Interrupt, syscall.SIGTERM)

	req := echo.NewRequest()
	i := 0
	for {
		select {
		case <-stop:
			err = c.Close()
			if err != nil {
				panic(err)
			}
			return
		default:
			req.Message = fmt.Sprintf("#%d", i)
			log.Printf("Sending Request %s\n", req.Message)
			res, err := c.Echo(context.Background(), req)
			if err != nil {
				panic(err)
			}
			log.Printf("Received Response %s\n", res.Message)
			time.Sleep(time.Second)
			i++
		}
	}
}
```

The above loop registers a `stop{:.keyword}` channel to receive a signal when the user hits `Ctrl+C{:.keyword}`,
and then starts sending a request to the server every second.

And that's it! We've now set up a simple echo client that can send requests to our server and print out the response.

We were able to use a simple `proto3{:.keyword}` file to define our request and response objects, and all we had to do was
implement the `EchoService{:.variable}` interface. Everything else was handled for us by **FRPC**.

# Next Steps

Now that we've seen how easy it is to use **FRPC**, we recommend you check out our [benchmarks]("/performance/rpc-benchmarks") page
to learn more about how and why **FRPC** is so fast.

If you want to learn more about how **FRPC** works under the hood, you can check out our [FRPC Concepts]("/concepts/frpc") page as well.

Finally, if you'd like to learn how to use [Frisbee]("/concepts/frisbee) (the underlying transport mechanism for FRPC)
to implement your **own messaging protocol** that's fast and performant, you can check out our [Getting Started with Frisbee]("/frisbee/getting-started") guide.

If you need any help or have any feedback about Frisbee or FRPC, please to check out our [Discord Community]("https://loopholelabs.io/discord")!
Our team would love to hear your thoughts and understand how you're planning on using FRPC, and we're always happy to help!
