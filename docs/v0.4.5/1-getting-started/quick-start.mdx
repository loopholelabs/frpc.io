---
title: Quick Start
order: 1
---

In this section we'll be going over how you can quickly get started with <Tooltip text={"Frisbee RPC"} content={"FRPC"}/>,
from defining your message types in a <Tooltip text={"Syntax used to describe protocol buffers"} content={"proto3"}/> file, to writing your first server and client.

We'll be building a simple echo service that will echo back the message it receives, and later on we'll also show how
you can use the Frisbee framework itself to build a more complex <Tooltip text={"Publish and Subscribe"} content={"PUB\/SUB"}/> service.

# Installation

<Note>
  It's important for you to note you can use the Frisbee framework itself to
  build a more complex{" "}
  <Tooltip text={"Publish and Subscribe"} content={"PUB/SUB"} /> service.{" "}
</Note>

To get started with <Tooltip text={"Frisbee RPC"} content={"FRPC"}/>, you'll need to make sure you have `Go{:.keyword}`
and the `protoc{:.keyword}` compiler installed. Then, you'll need to install
the `protoc-gen-frisbee{:.keyword}` <Tooltip text={"Plugins hook into the protoc compiler and allow for custom code generation"} content={"protoc plugin"}/>
which we will use to generate the server and client code.

## Prerequisites

- [Go](https://golang.org/doc/install) - FRPC works with `Go` version 1.17 or later. For installation instructions see [Go's Getting Started Guide](https://golang.org/doc/install).
- [Protocol Buffer Compiler (protoc)](https://developers.google.com/protocol-buffers) - FRPC works with `protoc{:.keyword}` version 3. For installation instructions see the [Protoc Getting Started Guide](https://developers.google.com/protoc/docs/getting_started).

If you're using MacOS and have [Brew](https://brew.sh/) installed, you can use `brew install go{:.keyword}`
to install Golang, and `brew install protoc{:.keyword}` to install the protoc compiler.

## Install the FRPC Plugin

To install the `protoc-gen-frisbee{:.keyword}` plugin, you'll first need to make sure that your

`$GOBIN{:.keyword}` environment variable is set and available in
your system path. See the [Go Environment Variables](https://golang.org/doc/code.html#GOPATH)
for more information, but in general, you can do this by adding the following to
your `~/.bashrc{:.keyword}` file:

```bash {1-2} title="~/.bashrc"
export GOBIN=$GOPATH/bin
export PATH=$PATH:$GOBIN
```

To install the `protoc-gen-frisbee{:.keyword}` plugin itself, you'll need to run the following command:

```bash
$ go install github.com/loopholelabs/frisbee/protoc-gen-frisbee@latest
```

This will install the `protoc-gen-frisbee{:.keyword}` plugin into your `$GOBIN{:.keyword}` directory
where it will be available for use by the `protoc{:.keyword}` compiler.

You can check that the plugin is installed and available by running the following command:

```bash
$ which protoc-gen-frisbee
/Users/<username>/go/bin/protoc-gen-frisbee # or $GOPATH/bin/protoc-gen-frisbee
```

# Create a Proto3 File

Now that we have the prerequisites and the `protoc-gen-frisbee{:.keyword}` plugin installed,
we can start writing our echo service. Let's start by creating a directory to house our project:

```bash
$ mkdir -p ~/frpc/echo
$ cd ~/frpc/echo
```

Now we'll create an `echo.proto{:.keyword}` file and define our message types:

```proto ~/echo/echo.proto
syntax = "proto3";

option go_package = "/echo";

message Request {
  string Message = 1;
}

message Response{
  string Message = 1;
}
```

You can see that we've defined two message types, one for the `Request{:.keyword}` and one for the `Response{:.keyword}`.

Next, we will define a new **Echo Service** in our `proto3{:.keyword}` file. This tells the compiler that we want to generate a server and client for this service.

```proto ~/echo/echo.proto
syntax = "proto3";

option go_package = "/echo";

// focus(1:3)
service EchoService {
  rpc Echo(Request) returns (Response);
}

message Request {
  string Message = 1;
}

message Response{
  string Message = 1;
}
```

And with that you should be ready. Next we'll start the `protoc{:.keyword}` compiler to generate
our FRPC server and client.

# Generate the Server and Client

Let's run the following command to generate the server and client code:

```bash
$ protoc --frisbee_out=. echo.proto
```

This command tells the `protoc{:.keyword}` compiler to generate the server and client code for us and
by specifying the `--frisbee_out{:.keyword}` flag, we're implicitly specifying that we want to use the

`protoc-gen-frisbee{:.keyword}` plugin.

If we wanted to be more explicit, we could have run the following command:

```bash
$ protoc --plugin=protoc-gen-frisbee=$GOBIN/protoc-gen-frisbee --frisbee_out=. echo.proto
```

These commands should have generated a new folder at `~/echo/echo{:.keyword}`, which
contains an `echo.frisbee.go{:.keyword}` file containing the server and client code. Within
that file, you'll find the following interface:

```go echo.frisbee.go
...

type EchoService interface {
	Echo(context.Context, *Request) (*Response, error)
}

...
```

All we have left to do is implement the `EchoService{:.keyword}` interface with our server-side logic,
and pass that into the server. The generated library will then be able to handle everything else for us.

# Setting up the Server

To set up our server, we simply need to implement the `EchoService{:.keyword}` interface and then start
the server. We'll start by creating a new `server/main.go{:.keyword}` file in our `~/frpc/echo{:.keyword}` directory:

```go ~/echo/server/server.go
package main

import (
	"context"
     "frisbee-examples/echo/echo"
)

type svc struct{}

func (s *svc) Echo(_ context.Context, req *echo.Request) (*echo.Response, error) {
	res := new(echo.Response)
	res.Message = req.Message
	return res, nil
}
```

As you can see we've created a new struct called `svc{:.keyword}` and implemented the `EchoService{:.keyword}` interface by
creating a new function called `Echo{:.keyword}` which takes a `context.Context{:.keyword}` and an `*echo.Request{:.keyword}` object.
We aren't really using the context in this example so we just ignore that and instead return an `*echo.Response{:.keyword}` object with the
same message as the request.

Now we can implement the server itself:

```go ~/echo/server/server.go
package main

import (
	"context"
	"github.com/loopholelabs/frisbee"
	"github.com/rs/zerolog"
     "frisbee-examples/echo/echo"
	"log"
	"os"
	"runtime"
	"time"
)

type svc struct{}

func (s *svc) Echo(_ context.Context, req *echo.Request) (*echo.Response, error) {
	res := new(echo.Response)
	res.Message = req.Message
	return res, nil
}

// focus(1:11)
func main() {
	frpcServer, err := echo.NewServer(new(svc), nil, nil)
	if err != nil {
		panic(err)
	}

	err = frisbeeServer.Start(":8080")
    if err != nil {
        panic(err)
    }
}

```
